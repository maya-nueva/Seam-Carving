# BEWARE!!! if you’re copying this into vscode or smth to run it, docs kind of messes the indents up, so if something isn’t working that’s probably why :’)


import numpy as np
import matplotlib.pyplot as plt
import cv2




image1_path = "twilightforest.jpg" # be aware that this path may not be the same across all computer setups!!!!
img1 = cv2.imread(image1_path)
img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB) # we convert our image into color RGB in order to work with it as a grayscale image later




def display(img):  
 plt.figure(figsize = (5,5))
 if img.ndim == 2:
    plt.imshow(img, cmap="gray")
#    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) # ensures that we don't have to rerun the color conversion for every new display line
 else:
    plt.imshow(img)
 plt.axis('off')
 plt.show()




def convert_to_grayscale(img):
#  img is an RGB image, represented as a 2D numpy array.
 out = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)
 return out




def get_energy_map(img):
# bright edges that appear in the map are stronger, higher energies,--> signifying pixel importance
# this will also show the lower energy levels that we want to eliminate
# Source: https://stackoverflow.com/questions/58149004/understanding-the-sobel-operation-output-for-creating-an-energy-map
 sobelX = cv2.Sobel(img, cv2.CV_32F, 1, 0, ksize=3)
 sobelY = cv2.Sobel(img, cv2.CV_32F, 0, 1, ksize=3)
 energyLevel = cv2.magnitude(sobelX, sobelY)
 image = energyLevel.astype(np.uint8)
 return image








#get the connecting vertical seam with weakest/dimmest pixels
def find_min_seam(img, energyMap):
 imgH, imgW = img.shape[:2] #get the image proportions
 seams = np.zeros_like(img, dtype = np.int32) #create an array with zeros (the same dimensions)
 toDelete = np.ones((imgH, imgW), dtype= bool)




 for h in range(1, imgH):
     for w in range(imgW):
         choices = [] #create array with pixels, find the lowest energy one
         #we look up to the three possible choices directly above, above to the left, above to the right


         if w > 0:  #check if the pixel we are on is on the edge. if so, only append pixels that actually exist
             choices.append([energyMap[h-1, w-1], w-1])
         if w < imgW -1:
             choices.append([energyMap[h-1, w+1], w+1])
         choices.append([energyMap[h-1, w], w])  #append pixel directly above as an option automatically


         # Resources:
         # https://discuss.python.org/t/allow-min-and-max-to-return-both-the-key-and-value/62990
         # https://stackoverflow.com/questions/54907754/how-does-lambda-work-in-python-with-max-function
         lowest_energy, x_position = min(choices, key=lambda x:x[0])
         energyMap[h, w] += lowest_energy
         seams[h, w] = x_position




 # reference for these lines:
 # https://karthikkaranth.me/blog/implementing-seam-carving-with-python/
 x = np.argmin(energyMap[-1]) #the minimum ending/cumulative energy value at the bottom
 #makes new arrays with the seams marked in boolean
 for h in reversed(range(imgH)):
     toDelete[h,x] = False #0
     x = seams[h, x]
 return toDelete








def removeVertSeams(img, deleteMap):
  H, W = img.shape[:2] #get the height and width of the image
  newImg = np.zeros((H,W-1,3), dtype= img.dtype) #creates new array the shape of the img but with one less column (bc were shrinking it), still of depth 3


  for channel in range(3): #for each channel r,g,b
    for row in range(H): #loop through all the rows of the image
      newImg[row, :, channel] = img[row, :, channel][deleteMap[row]] #and for that layer/channel of both new and og, copy the row from the img into the new one, but excluding the one pixel marked False in the delete map
  return newImg #return the beautiful new resized image


      # resources:
      # https://stackoverflow.com/questions/64180609/delete-both-row-and-column-in-numpy-array
      # np documentation: https://numpy.org/devdocs/reference/generated/numpy.delete.html




def addVertSeam(img, deleteMap):
 H, W = img.shape[:2] #get the height and width of the image
 imgCopy = img.copy()
 newImg = np.zeros((H,W+1,3), dtype= img.dtype) #creates new array the shape of the img but with one less column (bc were shrinking it), still of depth 3
 #loop through each layer in the image, and then through each row in that layer, and add a pixel to the right with the proper value based on the location of the False in the deleteMap
 for channel in range(3):
   for row in range(H):
     #to insert value in array at a certain index, np.insert(arrayName, index after, value)
     idx = np.where(deleteMap[row]==False)[0]
     newImg[row,:,channel] = np.insert(imgCopy[row,:,channel], idx+1, imgCopy[row,idx,channel])
 return newImg








def add_seams(img, setting):
 if setting == "horizontal": #if they want to add to the height aka add horizontally
   img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE) #rotate the image first
 
 
 #the whole process for getting the deleteMap
 greyImage = convert_to_grayscale(img)
 energyMap = get_energy_map(greyImage)
 deleteMap = find_min_seam(greyImage, energyMap)
 
 
 
 
 #add the vertical seam
 img = addVertSeam(img, deleteMap)
 
 
 if setting == "horizontal": #if we did this on a rotated image to increase height, rotate back to og orientation
   img = cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)
   return img #return beautiful resized image




#sources:
#for the numpy array where() function: https://datascienceparichay.com/article/find-index-of-element-in-numpy-array/#:~:text=How%20to%20find%20the%20index%20of%20element%20in%20numpy%20array,following%20example%20illustrates%20the%20usage.&text=Here%2C%20arr%20is%20the%20numpy,boolean%20True%20and%20False%20values.
#np documentation insert() function: https://numpy.org/doc/2.1/reference/generated/numpy.insert.html
#helped me debug: https://stackoverflow.com/questions/68143184/having-trouble-inserting-a-value-into-a-numpy-array#:~:text=Sorted%20by:,3%2C7076%2048%2070














# deals with horizontal OR vertical seams
def remove_seams (img, setting):
 if setting == "horizontal":
   img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)
 
 
 
 
 greyImage = convert_to_grayscale(img)
 energyMap = get_energy_map(greyImage)
 deleteMap = find_min_seam(greyImage, energyMap)
 
 
 
 
 img = removeVertSeams(img, deleteMap)
 
 
 
 
 if setting == "horizontal": # rotate img, get vert seam out, rotate back
   img = cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)
 return img






def change_scale(img, scaleW, scaleH): #user/coder will input their image and how much they want to scale the height and width by (e.g. i want it to be twice as wide but half as tall)
 h, w = img.shape[:2]
 
 
 goalW = int(w*scaleW)
 # THIS DEALS W/ WIDTH UNTIL ALL SEAMS YOU WANT GONE ARE DELETED:
 if scaleW < 1: #make the width smaller / thinner
   for i in range (w-goalW): #remove correct amount of seams
     img = remove_seams(img, "vertical") #find and remove lowest energy seam
 elif scaleW > 1: # make it wider
    for i in range(goalW-w):
      img = add_seams(img, "vertical") #find and add seams for as many new pixels as you need
  #if the scaleW is = 1, nothing will happen because it does not need to be resized
 
 
 
 
 #  LIKEWISE, THIS DEALS WITH HEIGHT:
 h, w = img.shape[:2]
 goalH = int(h*scaleH)
 if scaleH < 1: #make it shorter
   for i in range(h-goalH):
     img = remove_seams(img, "horizontal") #find and remove seams
 elif scaleH > 1: # make it taller
   for i in range(goalH-h): #total num of pixels you need to add, larger (ideal) size - current smaller size
       img = add_seams(img, "horizontal") #find and add seam, this is repeated for as many new pixels as you need
  #if the scaleH is = 1, nothing will happen because it does not need to be resized
 return img #this is the FINAL image. very beautiful.






# we put all the running func stuff we call down here so it is clearer what our work flow is, if that makes sense:
display(img1) #the original image
imgG = convert_to_grayscale(img1)
e_m = get_energy_map(imgG)
display(e_m) #the energy map image, aka the sobel filtered img
resized = change_scale(img1, 0.8, 0.8) #the number 0.9 is a percent of how much you want ur img to be kept (ie 0.9 means that only 10% of seams are actually eliminated)
display(resized) #the cropped or elongated image. the FINAL PRODUCT <3333 *u* (OuO)b


# displays change in dimension (if something doesn’t work while running the code (if you are running the code) it’s probably this line bc i added it from docs sorry


dimension = img1.shape
height = img1.shape[0]
width = img1.shape[1]
channels = img1.shape[2]
print("the original image dimensions are height, width, and channel. Seen here:", height,width,channels)


dimension = resized.shape
height = resized.shape[0]
width = resized.shape[1]
print("the resized image dimensions are height, width, and channel. Seen here:", height,width,channels)



