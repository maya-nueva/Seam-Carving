import numpy as np
import matplotlib.pyplot as plt
import cv2

image1_path = "./paint copy.jpeg" # be aware that this path may not be the same across all computer setups!!!!
img1 = cv2.imread(image1_path)
img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB) # we convert our image into color RGB in order to work with it as a grayscale image later


def display(img):    # Shows image
   plt.figure(figsize = (5,5))
   if img.ndim == 2:
      plt.imshow(img, cmap="gray")
#    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) # ensures that we don't have to rerun the color conversion for every new display line
   else:
      plt.imshow(img)
   plt.axis('off')
   plt.show()


def convert_to_grayscale(img):
#  img is an RGB image, represented as a 2D numpy array.
   out = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)
   return out



def get_energy_map(img):
# bright edges that appear in the map are stronger, higher energies
# that signify whether an object is of importance (& whether to keep them)
# this will also show the lower energy levels that we want to eliminate
# Helpful Source: https://stackoverflow.com/questions/58149004/understanding-the-sobel-operation-output-for-creating-an-energy-map
   sobelX = cv2.Sobel(img, cv2.CV_32F, 1, 0, ksize=3)
   sobelY = cv2.Sobel(img, cv2.CV_32F, 0, 1, ksize=3)
   energyLevel = cv2.magnitude(sobelX, sobelY)
   image = energyLevel.astype(np.uint8)
   return image



#get the best seam; top down approach
def find_min_seam(img, energyMap):
   imgH, imgW = img.shape[:2] #get the image proportions

   seams = np.zeros_like(img, dtype = np.int32) #create an array with zeros (the same dimensions)
   toDelete = np.ones((imgH, imgW), dtype= bool)


   for h in range(1, imgH):
       for w in range(imgW):
           choices = [] #create array with pixels, find the lowest energy one


           if w > 0:  #check if the pixel we are on is on the edge. if so, only append pixels that actually exist
               choices.append([energyMap[h-1, w-1], w-1])
           if w < imgW -1:
               choices.append([energyMap[h-1, w+1], w+1])
           
           choices.append([energyMap[h-1, w], w])  #append pixel directly above as an option automatically

           #what I used to understand this syntax: https://discuss.python.org/t/allow-min-and-max-to-return-both-the-key-and-value/62990
           #and https://stackoverflow.com/questions/54907754/how-does-lambda-work-in-python-with-max-function
           lowest_energy, x_position = min(choices, key=lambda x:x[0])


           energyMap[h, w] += lowest_energy
           seams[h, w] = x_position


   #reference for these lines: https://karthikkaranth.me/blog/implementing-seam-carving-with-python/
   x = np.argmin(energyMap[-1]) #the minimum ending/cumulative energy value at the bottom
  
  
   #makes new arrays with the seams marked in boolean
   for h in reversed(range(imgH)):
       toDelete[h,x] = False #0
       x = seams[h, x]
   return toDelete


def removeVertSeams(img, deleteMap): # this is removing seams from the image:
    H, W = img.shape[:2]

    newImg = np.zeros((H, W-1), dtype= img.dtype)
    for row in range(H):
       newImg[row] = img[row][deleteMap[row]]
    return newImg
    # past attempts: 
        # --> mask = np.stack([mask]*3, axis=2)
        # img[Row].pop(Column) #pop apparently doesnt work on numpy arrays
        # source https://stackoverflow.com/questions/64180609/delete-both-row-and-column-in-numpy-array
        # np documentation: https://numpy.org/devdocs/reference/generated/numpy.delete.html





def remove_seams (img, setting = "vertical"):
  energyMap = get_energy_map(img) #added in for speed
  deleteMap = find_min_seam(img, energyMap) #added in for speed

  if setting == "vertical":
      deleteMap = find_min_seam(img, energyMap)
      img = removeVertSeams(img, deleteMap)
  else:  # rotate img, get vert seam out, rotate back
      rotatedimg = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)
      rotatedEnergyMap = get_energy_map(rotatedimg)
      deleteMap = find_min_seam(rotatedimg, rotatedEnergyMap)
      rotatedimg = removeVertSeams(rotatedimg, deleteMap)
      img = cv2.rotate(rotatedimg, cv2.ROTATE_90_COUNTERCLOCKWISE)
  return img



# def addVertSeams(img):
#   # add stuff here
#   # !!!
#   # !!!
#   # !!!
#   pass

# def add_seams(img, setting = "vertical"):
#   if setting == "vertical":
#       img = addVertSeams(img)
#   else:
#     # rotate img, get vert seam out, rotate back
#     rotatingimg = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)
#     rotatedimgNew = addVertSeams(rotatingimg)
#     img = cv2.rotate(rotatedimgNew, cv2.ROTATE_90_COUNTERCLOCKWISE)
#   return img


def change_scale(img, scaleW, scaleH): #user/coder will input their image and how much they want to scale the height and width by (e.g. i want it to be twice as wide but half as tall)  
   h, w = img.shape[:2]

   goalW = int(w*scaleW)
# THIS DEALS W/ WIDTH UNTIL ALL SEAMS YOU WANT GONE ARE DELETED:
   if scaleW < 1: #make the width smaller / thinner
    for i in range (w-goalW): #remove correct amount of seams
       img = remove_seams(img, "vertical") #find and remove lowest energy seam
       print("width worked!")
   elif scaleW > 1: # make it wider
        print("adding seams not yet implemented!!")
#        for i in range(goalW-w):
#            img = add_seams(img, "vertical") #find and add seams for as many new pixels as you need (question for wes about same seam?)
   #if the scaleW is = 1, nothing will happen because it does not need to be resized
  

#  LIKEWISE, THIS DEALS WITH HEIGHT:
   h, w = img.shape[:2]
   goalH = int(h*scaleH)
   if scaleH < 1: #make it shorter
       for i in range(h-goalH):
           img = remove_seams(img, "horizontal") #find and remove seams
           print("height worked")
   elif scaleH > 1: # make it taller
      print("adding seams not yet implemented!!")
#        for i in range(goalH-h):
#            img = add_seams(img, "horizontal") #find and add seams
   #if the scaleH is = 1, nothing will happen because it does not need to be resized
   newImg = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)
   return newImg


   

# i put all the stuff we call down here so it is clearer what our work flow is, if that makes sense:
display(img1) #the original image
imgG = convert_to_grayscale(img1)
e_m = get_energy_map(imgG) 
display(e_m) #the energy map image, aka the sobel filtered img
resized = change_scale(imgG, 1, 0.8) #the number 0.9 is a percent of how much you want ur img to be kept (ie 0.9 means that only 10% of seams are actually eliminated)
display(resized) #the cropped or elongated image



dimension = img1.shape
height = img1.shape[0]
width = img1.shape[1]
channels = img1.shape[2]
print("the original image dimensions are height, width, and channel. Seen here:", height,width,channels)


dimension = resized.shape
height = resized.shape[0]
width = resized.shape[1]
print("the resized image dimensions are height, width, and channel. Seen here:", height,width,channels)

