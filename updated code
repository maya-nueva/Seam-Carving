import numpy as np
import matplotlib.pyplot as plt
import cv2

image1_path = "./images/field.jpg" # be aware that this path may not be the same across all computer setups!!!!
img1 = cv2.imread(image1_path)
img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB) # we convert our image into color RGB in order to work with it as a grayscale image later

def display(img):
    # Show image
    plt.figure(figsize = (5,5))
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) # this ensures that we don't have to rerun the color conversion for every new display line
    plt.axis('off')
    plt.show()


def convert_to_grayscale(img):
    '''img is an RGB image, represented as a 2D numpy array.'''
    out = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)
    return out

imgG = convert_to_grayscale(img1)


def get_energy_map(img):
    sobelX = cv2.Sobel(img, cv2.CV_32F, 1, 0, ksize=3)
    sobelY = cv2.Sobel(img, cv2.CV_32F, 0, 1, ksize=3)
    energyLevel = cv2.magnitude(sobelX, sobelY) 
    # bright edges that appear in the map are stronger, higher energies 
    # that signify whether an object is of importance (& whether to keep them)
    # this will also show the lower energy levels that we want to eliminate
    image = energyLevel.astype(np.uint8)
    # Helpful Source: https://stackoverflow.com/questions/58149004/understanding-the-sobel-operation-output-for-creating-an-energy-map 
    return image

display(imgG) 
e_m = get_energy_map(imgG) 
display(e_m) 


#get the best seam its top down

def min_seam_vert(img):
    imgH, imgW = img.shape #get the image proportions
    imageEnergy = get_energy_map(img)
    energyMap = imageEnergy.copy()
    seams = np.zeros_like(img, dtype=np.int32) #create an array with zeros (the same dimensions)
    toDelete = np.ones((imgH, imgW), dtype=np.bool) 

    for h in range(1, imgH):
        for w in range(imgW):
            choices = [] #create array with pixels, find the lowest energy one

            #check if the pixel we are on is on the edge. if so, only append pixels that actually exist
            if w > 0: 
                choices.append([energyMap[h-1, w-1], w-1])
            if w < imgW -1:
                choices.append([energyMap[h-1, w+1], w-1])

            choices.append([energyMap[h-1, w], w-1]) #append pixel directly above as an option automatically

            #what I used to understand this syntax: https://discuss.python.org/t/allow-min-and-max-to-return-both-the-key-and-value/62990
            #and https://stackoverflow.com/questions/54907754/how-does-lambda-work-in-python-with-max-function
            lowest_energy, x_position = min(choices, key=lambda x:x[0])

            energyMap[h, w] += lowest_energy
            seams[h, w] = x_position

    #reference for these lines: https://karthikkaranth.me/blog/implementing-seam-carving-with-python/
    x = np.argmin(energyMap[-1]) #the minimum ending/cumulative energy value at the bottom
   
   #makes new arrays with the seams marked in boolean
    for h in reversed(range(imgH)):
        toDelete[int(h),int(x)] = 0
        x = seams[h, x]


    return toDelete
    
def min_seam_horiz(img):
    horizImg = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE) #src: https://www.geeksforgeeks.org/python/python-opencv-cv2-rotate-method/
    #run min seam

min_seam_vert(e_m)

def remove_seams(img):
    imgRow, imgColumn = img.shape #get the image proportions for deletion
    min_delete = min_seam(img)
    # booleans to delete
    
def repeat_cropping():
    pass
