import numpy as np
import matplotlib.pyplot as plt
import cv2

image1_path = "/Users/kelzhao/Desktop/Seam-Carving/images/field.jpg" # be aware that this path may not be the same across all computer setups!!!!
img1 = cv2.imread(image1_path)
img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB) # we convert our image into color RGB in order to work with it as a grayscale image later


def display(img):    # Shows image
   plt.figure(figsize = (5,5))
   if img.ndim == 2:
      plt.imshow(img, cmap="gray")
#    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) # ensures that we don't have to rerun the color conversion for every new display line
   else:
      plt.imshow(img)
   plt.axis('off')
   plt.show()


def convert_to_grayscale(img):
#  img is an RGB image, represented as a 2D numpy array.
   out = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)
   return out



def get_energy_map(img):
# bright edges that appear in the map are stronger, higher energies
# that signify whether an object is of importance (& whether to keep them)
# this will also show the lower energy levels that we want to eliminate
# Helpful Source: https://stackoverflow.com/questions/58149004/understanding-the-sobel-operation-output-for-creating-an-energy-map
   sobelX = cv2.Sobel(img, cv2.CV_32F, 1, 0, ksize=3)
   sobelY = cv2.Sobel(img, cv2.CV_32F, 0, 1, ksize=3)
   energyLevel = cv2.magnitude(sobelX, sobelY)
   image = energyLevel.astype(np.uint8)
   return image



#get the best seam; top down approach
def find_min_seam(img, energyMap):
   imgH, imgW = img.shape[:2] #get the image proportions

   seams = np.zeros_like(img, dtype = np.int32) #create an array with zeros (the same dimensions)
   toDelete = np.ones((imgH, imgW), dtype= bool)


   for h in range(1, imgH):
       for w in range(imgW):
           choices = [] #create array with pixels, find the lowest energy one


           if w > 0:  #check if the pixel we are on is on the edge. if so, only append pixels that actually exist
               choices.append([energyMap[h-1, w-1], w-1])
           if w < imgW -1:
               choices.append([energyMap[h-1, w+1], w+1])
           
           choices.append([energyMap[h-1, w], w])  #append pixel directly above as an option automatically

           #what I used to understand this syntax: https://discuss.python.org/t/allow-min-and-max-to-return-both-the-key-and-value/62990
           #and https://stackoverflow.com/questions/54907754/how-does-lambda-work-in-python-with-max-function
           lowest_energy, x_position = min(choices, key=lambda x:x[0])


           energyMap[h, w] += lowest_energy
           seams[h, w] = x_position


   #reference for these lines: https://karthikkaranth.me/blog/implementing-seam-carving-with-python/
   x = np.argmin(energyMap[-1]) #the minimum ending/cumulative energy value at the bottom
  
  
   #makes new arrays with the seams marked in boolean
   for h in reversed(range(imgH)):
       toDelete[h,x] = False #0
       x = seams[h, x]
   return toDelete






def removeVertSeams(img, deleteMap): # this is removing seams from the image:
    H, W = img.shape[:2] #get the height and width of the image
    newImg = np.zeros((H,W-1,3), dtype= img.dtype) #creates new array the shape of the img but with one less column (bc were shrinking it), still of depth 3

    for channel in range(3): #for each channel r,g,b
      for row in range(H): #loop through all the rows of the image
        newImg[row, :, channel] = img[row, :, channel][deleteMap[row]] #and for that layer/channel of both new and og, copy the row from the img into the new one, but excluding the one pixel marked False in the delete map
    return newImg #return the beautiful new resized image
    
    # past attempts: 
        # --> mask = np.stack([mask]*3, axis=2)
        # img[Row].pop(Column) #pop apparently doesnt work on numpy arrays
        # source https://stackoverflow.com/questions/64180609/delete-both-row-and-column-in-numpy-array
        # np documentation: https://numpy.org/devdocs/reference/generated/numpy.delete.html


def remove_seams (img, setting): #removed the = "vertical", does that matter?
  if setting == "horizontal":
    img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)

  greyImage = convert_to_grayscale(img)
  energyMap = get_energy_map(greyImage)
  deleteMap = find_min_seam(greyImage, energyMap)

  img = removeVertSeams(img, deleteMap)

  if setting == "horizontal": # rotate img, get vert seam out, rotate back
    img = cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)
  return img





def addVertSeam(img, deleteMap):
  # make a new image with the same dimensions as the og img but +1 in width
  H, W = img.shape[:2] #get the height and width of the image
  imgCopy = img.copy()
  newImg = np.zeros((H,W+1,3), dtype= img.dtype) #creates new array the shape of the img but with one less column (bc were shrinking it), still of depth 3
  #loop through each layer in the image, and then through each row in that layer, and add a pixel to the right with the proper value based on the location of the False in the deleteMap
  for channel in range(3):
    for row in range(H):
      #to insert value in array at a certain index, np.insert(arrayName, index after, value)
      idx = np.where(deleteMap[row]==False)[0]
      newImg[row,:,channel] = np.insert(imgCopy[row,:,channel], idx+1, imgCopy[row,idx,channel]) 
  return newImg


def add_seams(img, setting):
  if setting == "horizontal": #if they want to add to the height aka add horizontally
    img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE) #rotate the image first

  #the whole process for getting the deleteMap (do we want to make this into a mini function since it repeats a couple of times?)

  greyImage = convert_to_grayscale(img)
  energyMap = get_energy_map(greyImage)
  deleteMap = find_min_seam(greyImage, energyMap)

  #add the vertical seam
  img = addVertSeam(img, deleteMap)

  if setting == "horizontal": #if we did this on a rotated image to increase height, rotate back to og orientation
    img = cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)
  
  return img #return beautiful resized image

#sources:
#for the numpy array where() function: https://datascienceparichay.com/article/find-index-of-element-in-numpy-array/#:~:text=How%20to%20find%20the%20index%20of%20element%20in%20numpy%20array,following%20example%20illustrates%20the%20usage.&text=Here%2C%20arr%20is%20the%20numpy,boolean%20True%20and%20False%20values.
#np documentation insert() function: https://numpy.org/doc/2.1/reference/generated/numpy.insert.html
#helped me debug: https://stackoverflow.com/questions/68143184/having-trouble-inserting-a-value-into-a-numpy-array#:~:text=Sorted%20by:,3%2C7076%2048%2070





def change_scale(img, scaleW, scaleH): #user/coder will input their image and how much they want to scale the height and width by (e.g. i want it to be twice as wide but half as tall)  
  h, w = img.shape[:2]
  #  greyImage = convert_to_grayscale(img)

  goalW = int(w*scaleW)
# THIS DEALS W/ WIDTH UNTIL ALL SEAMS YOU WANT GONE ARE DELETED:
  if scaleW < 1: #make the width smaller / thinner
    for i in range (w-goalW): #remove correct amount of seams
      img = remove_seams(img, "vertical") #find and remove lowest energy seam
      print("width worked!")
  elif scaleW > 1: # make it wider
    print("adding seams not yet implemented!!")
#        for i in range(goalW-w):
#            img = add_seams(img, "vertical") #find and add seams for as many new pixels as you need (question for wes about same seam?)
   #if the scaleW is = 1, nothing will happen because it does not need to be resized
  

#  LIKEWISE, THIS DEALS WITH HEIGHT:
  h, w = img.shape[:2]
  goalH = int(h*scaleH)
  if scaleH < 1: #make it shorter
    for i in range(h-goalH):
      img = remove_seams(img, "horizontal") #find and remove seams
      print("height worked")
  elif scaleH > 1: # make it taller
    for i in range(goalH-h): #total num of pixels you need to add, larger (ideal) size - current smaller size
        img = add_seams(img, "horizontal") #find and add seam, this is repeated for as many new pixels as you need
   #if the scaleH is = 1, nothing will happen because it does not need to be resized

  return img #this is the FINAL image. very beautiful.


   

# i put all the stuff we call down here so it is clearer what our work flow is, if that makes sense:
display(img1) #the original image
imgG = convert_to_grayscale(img1)
e_m = get_energy_map(imgG) 
display(e_m) #the energy map image, aka the sobel filtered img
resized = change_scale(img1, 0.8, 1.2) #the number 0.9 is a percent of how much you want ur img to be kept (ie 0.9 means that only 10% of seams are actually eliminated)
display(resized) #the cropped or elongated image



dimension = img1.shape
height = img1.shape[0]
width = img1.shape[1]
channels = img1.shape[2]
print("the original image dimensions are height, width, and channel. Seen here:", height,width,channels)


dimension = resized.shape
height = resized.shape[0]
width = resized.shape[1]
print("the resized image dimensions are height, width, and channel. Seen here:", height,width,channels)

